/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dicer";
exports.ids = ["vendor-chunks/dicer"];
exports.modules = {

/***/ "(rsc)/./node_modules/dicer/lib/Dicer.js":
/*!*****************************************!*\
  !*** ./node_modules/dicer/lib/Dicer.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var WritableStream = (__webpack_require__(/*! stream */ \"stream\").Writable)\n                     || (__webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\").Writable),\n    inherits = (__webpack_require__(/*! util */ \"util\").inherits);\n\nvar StreamSearch = __webpack_require__(/*! streamsearch */ \"(rsc)/./node_modules/dicer/node_modules/streamsearch/lib/sbmh.js\");\n\nvar PartStream = __webpack_require__(/*! ./PartStream */ \"(rsc)/./node_modules/dicer/lib/PartStream.js\"),\n    HeaderParser = __webpack_require__(/*! ./HeaderParser */ \"(rsc)/./node_modules/dicer/lib/HeaderParser.js\");\n\nvar DASH = 45,\n    B_ONEDASH = new Buffer('-'),\n    B_CRLF = new Buffer('\\r\\n'),\n    EMPTY_FN = function() {};\n\nfunction Dicer(cfg) {\n  if (!(this instanceof Dicer))\n    return new Dicer(cfg);\n  WritableStream.call(this, cfg);\n\n  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string'))\n    throw new TypeError('Boundary required');\n\n  if (typeof cfg.boundary === 'string')\n    this.setBoundary(cfg.boundary);\n  else\n    this._bparser = undefined;\n\n  this._headerFirst = cfg.headerFirst;\n\n  var self = this;\n\n  this._dashes = 0;\n  this._parts = 0;\n  this._finished = false;\n  this._realFinish = false;\n  this._isPreamble = true;\n  this._justMatched = false;\n  this._firstWrite = true;\n  this._inHeader = true;\n  this._part = undefined;\n  this._cb = undefined;\n  this._ignoreData = false;\n  this._partOpts = (typeof cfg.partHwm === 'number'\n                    ? { highWaterMark: cfg.partHwm }\n                    : {});\n  this._pause = false;\n\n  this._hparser = new HeaderParser(cfg);\n  this._hparser.on('header', function(header) {\n    self._inHeader = false;\n    self._part.emit('header', header);\n  });\n\n}\ninherits(Dicer, WritableStream);\n\nDicer.prototype.emit = function(ev) {\n  if (ev === 'finish' && !this._realFinish) {\n    if (!this._finished) {\n      var self = this;\n      process.nextTick(function() {\n        self.emit('error', new Error('Unexpected end of multipart data'));\n        if (self._part && !self._ignoreData) {\n          var type = (self._isPreamble ? 'Preamble' : 'Part');\n          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));\n          self._part.push(null);\n          process.nextTick(function() {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          });\n          return;\n        }\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      });\n    }\n  } else\n    WritableStream.prototype.emit.apply(this, arguments);\n};\n\nDicer.prototype._write = function(data, encoding, cb) {\n  // ignore unexpected data (e.g. extra trailer data after finished)\n  if (!this._hparser && !this._bparser)\n    return cb();\n\n  if (this._headerFirst && this._isPreamble) {\n    if (!this._part) {\n      this._part = new PartStream(this._partOpts);\n      if (this._events.preamble)\n        this.emit('preamble', this._part);\n      else\n        this._ignore();\n    }\n    var r = this._hparser.push(data);\n    if (!this._inHeader && r !== undefined && r < data.length)\n      data = data.slice(r);\n    else\n      return cb();\n  }\n\n  // allows for \"easier\" testing\n  if (this._firstWrite) {\n    this._bparser.push(B_CRLF);\n    this._firstWrite = false;\n  }\n\n  this._bparser.push(data);\n\n  if (this._pause)\n    this._cb = cb;\n  else\n    cb();\n};\n\nDicer.prototype.reset = function() {\n  this._part = undefined;\n  this._bparser = undefined;\n  this._hparser = undefined;\n};\n\nDicer.prototype.setBoundary = function(boundary) {\n  var self = this;\n  this._bparser = new StreamSearch('\\r\\n--' + boundary);\n  this._bparser.on('info', function(isMatch, data, start, end) {\n    self._oninfo(isMatch, data, start, end);\n  });\n};\n\nDicer.prototype._ignore = function() {\n  if (this._part && !this._ignoreData) {\n    this._ignoreData = true;\n    this._part.on('error', EMPTY_FN);\n    // we must perform some kind of read on the stream even though we are\n    // ignoring the data, otherwise node's Readable stream will not emit 'end'\n    // after pushing null to the stream\n    this._part.resume();\n  }\n};\n\nDicer.prototype._oninfo = function(isMatch, data, start, end) {\n  var buf, self = this, i = 0, r, ev, shouldWriteMore = true;\n\n  if (!this._part && this._justMatched && data) {\n    while (this._dashes < 2 && (start + i) < end) {\n      if (data[start + i] === DASH) {\n        ++i;\n        ++this._dashes;\n      } else {\n        if (this._dashes)\n          buf = B_ONEDASH;\n        this._dashes = 0;\n        break;\n      }\n    }\n    if (this._dashes === 2) {\n      if ((start + i) < end && this._events.trailer)\n        this.emit('trailer', data.slice(start + i, end));\n      this.reset();\n      this._finished = true;\n      // no more parts will be added\n      if (self._parts === 0) {\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      }\n    }\n    if (this._dashes)\n      return;\n  }\n  if (this._justMatched)\n    this._justMatched = false;\n  if (!this._part) {\n    this._part = new PartStream(this._partOpts);\n    this._part._read = function(n) {\n      self._unpause();\n    };\n    ev = this._isPreamble ? 'preamble' : 'part';\n    if (this._events[ev])\n      this.emit(ev, this._part);\n    else\n      this._ignore();\n    if (!this._isPreamble)\n      this._inHeader = true;\n  }\n  if (data && start < end && !this._ignoreData) {\n    if (this._isPreamble || !this._inHeader) {\n      if (buf)\n        shouldWriteMore = this._part.push(buf);\n      shouldWriteMore = this._part.push(data.slice(start, end));\n      if (!shouldWriteMore)\n        this._pause = true;\n    } else if (!this._isPreamble && this._inHeader) {\n      if (buf)\n        this._hparser.push(buf);\n      r = this._hparser.push(data.slice(start, end));\n      if (!this._inHeader && r !== undefined && r < end)\n        this._oninfo(false, data, start + r, end);\n    }\n  }\n  if (isMatch) {\n    this._hparser.reset();\n    if (this._isPreamble)\n      this._isPreamble = false;\n    else {\n      ++this._parts;\n      this._part.on('end', function() {\n        if (--self._parts === 0) {\n          if (self._finished) {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          } else {\n            self._unpause();\n          }\n        }\n      });\n    }\n    this._part.push(null);\n    this._part = undefined;\n    this._ignoreData = false;\n    this._justMatched = true;\n    this._dashes = 0;\n  }\n};\n\nDicer.prototype._unpause = function() {\n  if (!this._pause)\n    return;\n\n  this._pause = false;\n  if (this._cb) {\n    var cb = this._cb;\n    this._cb = undefined;\n    cb();\n  }\n};\n\nmodule.exports = Dicer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGljZXIvbGliL0RpY2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixzREFBMEI7QUFDL0Msd0JBQXdCLHlHQUFtQztBQUMzRCxlQUFlLGtEQUF3Qjs7QUFFdkMsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQWM7O0FBRXpDLGlCQUFpQixtQkFBTyxDQUFDLGtFQUFjO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFnQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnJpc3RvLW5leHQvLi9ub2RlX21vZHVsZXMvZGljZXIvbGliL0RpY2VyLmpzP2RiZGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFdyaXRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuV3JpdGFibGVcbiAgICAgICAgICAgICAgICAgICAgIHx8IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLldyaXRhYmxlLFxuICAgIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xuXG52YXIgU3RyZWFtU2VhcmNoID0gcmVxdWlyZSgnc3RyZWFtc2VhcmNoJyk7XG5cbnZhciBQYXJ0U3RyZWFtID0gcmVxdWlyZSgnLi9QYXJ0U3RyZWFtJyksXG4gICAgSGVhZGVyUGFyc2VyID0gcmVxdWlyZSgnLi9IZWFkZXJQYXJzZXInKTtcblxudmFyIERBU0ggPSA0NSxcbiAgICBCX09ORURBU0ggPSBuZXcgQnVmZmVyKCctJyksXG4gICAgQl9DUkxGID0gbmV3IEJ1ZmZlcignXFxyXFxuJyksXG4gICAgRU1QVFlfRk4gPSBmdW5jdGlvbigpIHt9O1xuXG5mdW5jdGlvbiBEaWNlcihjZmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERpY2VyKSlcbiAgICByZXR1cm4gbmV3IERpY2VyKGNmZyk7XG4gIFdyaXRhYmxlU3RyZWFtLmNhbGwodGhpcywgY2ZnKTtcblxuICBpZiAoIWNmZyB8fCAoIWNmZy5oZWFkZXJGaXJzdCAmJiB0eXBlb2YgY2ZnLmJvdW5kYXJ5ICE9PSAnc3RyaW5nJykpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm91bmRhcnkgcmVxdWlyZWQnKTtcblxuICBpZiAodHlwZW9mIGNmZy5ib3VuZGFyeSA9PT0gJ3N0cmluZycpXG4gICAgdGhpcy5zZXRCb3VuZGFyeShjZmcuYm91bmRhcnkpO1xuICBlbHNlXG4gICAgdGhpcy5fYnBhcnNlciA9IHVuZGVmaW5lZDtcblxuICB0aGlzLl9oZWFkZXJGaXJzdCA9IGNmZy5oZWFkZXJGaXJzdDtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fZGFzaGVzID0gMDtcbiAgdGhpcy5fcGFydHMgPSAwO1xuICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICB0aGlzLl9yZWFsRmluaXNoID0gZmFsc2U7XG4gIHRoaXMuX2lzUHJlYW1ibGUgPSB0cnVlO1xuICB0aGlzLl9qdXN0TWF0Y2hlZCA9IGZhbHNlO1xuICB0aGlzLl9maXJzdFdyaXRlID0gdHJ1ZTtcbiAgdGhpcy5faW5IZWFkZXIgPSB0cnVlO1xuICB0aGlzLl9wYXJ0ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9jYiA9IHVuZGVmaW5lZDtcbiAgdGhpcy5faWdub3JlRGF0YSA9IGZhbHNlO1xuICB0aGlzLl9wYXJ0T3B0cyA9ICh0eXBlb2YgY2ZnLnBhcnRId20gPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8geyBoaWdoV2F0ZXJNYXJrOiBjZmcucGFydEh3bSB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pO1xuICB0aGlzLl9wYXVzZSA9IGZhbHNlO1xuXG4gIHRoaXMuX2hwYXJzZXIgPSBuZXcgSGVhZGVyUGFyc2VyKGNmZyk7XG4gIHRoaXMuX2hwYXJzZXIub24oJ2hlYWRlcicsIGZ1bmN0aW9uKGhlYWRlcikge1xuICAgIHNlbGYuX2luSGVhZGVyID0gZmFsc2U7XG4gICAgc2VsZi5fcGFydC5lbWl0KCdoZWFkZXInLCBoZWFkZXIpO1xuICB9KTtcblxufVxuaW5oZXJpdHMoRGljZXIsIFdyaXRhYmxlU3RyZWFtKTtcblxuRGljZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldikge1xuICBpZiAoZXYgPT09ICdmaW5pc2gnICYmICF0aGlzLl9yZWFsRmluaXNoKSB7XG4gICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgbXVsdGlwYXJ0IGRhdGEnKSk7XG4gICAgICAgIGlmIChzZWxmLl9wYXJ0ICYmICFzZWxmLl9pZ25vcmVEYXRhKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSAoc2VsZi5faXNQcmVhbWJsZSA/ICdQcmVhbWJsZScgOiAnUGFydCcpO1xuICAgICAgICAgIHNlbGYuX3BhcnQuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IodHlwZSArICcgdGVybWluYXRlZCBlYXJseSBkdWUgdG8gdW5leHBlY3RlZCBlbmQgb2YgbXVsdGlwYXJ0IGRhdGEnKSk7XG4gICAgICAgICAgc2VsZi5fcGFydC5wdXNoKG51bGwpO1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9yZWFsRmluaXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICBzZWxmLl9yZWFsRmluaXNoID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX3JlYWxGaW5pc2ggPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICBzZWxmLl9yZWFsRmluaXNoID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5EaWNlci5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG4gIC8vIGlnbm9yZSB1bmV4cGVjdGVkIGRhdGEgKGUuZy4gZXh0cmEgdHJhaWxlciBkYXRhIGFmdGVyIGZpbmlzaGVkKVxuICBpZiAoIXRoaXMuX2hwYXJzZXIgJiYgIXRoaXMuX2JwYXJzZXIpXG4gICAgcmV0dXJuIGNiKCk7XG5cbiAgaWYgKHRoaXMuX2hlYWRlckZpcnN0ICYmIHRoaXMuX2lzUHJlYW1ibGUpIHtcbiAgICBpZiAoIXRoaXMuX3BhcnQpIHtcbiAgICAgIHRoaXMuX3BhcnQgPSBuZXcgUGFydFN0cmVhbSh0aGlzLl9wYXJ0T3B0cyk7XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLnByZWFtYmxlKVxuICAgICAgICB0aGlzLmVtaXQoJ3ByZWFtYmxlJywgdGhpcy5fcGFydCk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuX2lnbm9yZSgpO1xuICAgIH1cbiAgICB2YXIgciA9IHRoaXMuX2hwYXJzZXIucHVzaChkYXRhKTtcbiAgICBpZiAoIXRoaXMuX2luSGVhZGVyICYmIHIgIT09IHVuZGVmaW5lZCAmJiByIDwgZGF0YS5sZW5ndGgpXG4gICAgICBkYXRhID0gZGF0YS5zbGljZShyKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY2IoKTtcbiAgfVxuXG4gIC8vIGFsbG93cyBmb3IgXCJlYXNpZXJcIiB0ZXN0aW5nXG4gIGlmICh0aGlzLl9maXJzdFdyaXRlKSB7XG4gICAgdGhpcy5fYnBhcnNlci5wdXNoKEJfQ1JMRik7XG4gICAgdGhpcy5fZmlyc3RXcml0ZSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fYnBhcnNlci5wdXNoKGRhdGEpO1xuXG4gIGlmICh0aGlzLl9wYXVzZSlcbiAgICB0aGlzLl9jYiA9IGNiO1xuICBlbHNlXG4gICAgY2IoKTtcbn07XG5cbkRpY2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9wYXJ0ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9icGFyc2VyID0gdW5kZWZpbmVkO1xuICB0aGlzLl9ocGFyc2VyID0gdW5kZWZpbmVkO1xufTtcblxuRGljZXIucHJvdG90eXBlLnNldEJvdW5kYXJ5ID0gZnVuY3Rpb24oYm91bmRhcnkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9icGFyc2VyID0gbmV3IFN0cmVhbVNlYXJjaCgnXFxyXFxuLS0nICsgYm91bmRhcnkpO1xuICB0aGlzLl9icGFyc2VyLm9uKCdpbmZvJywgZnVuY3Rpb24oaXNNYXRjaCwgZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIHNlbGYuX29uaW5mbyhpc01hdGNoLCBkYXRhLCBzdGFydCwgZW5kKTtcbiAgfSk7XG59O1xuXG5EaWNlci5wcm90b3R5cGUuX2lnbm9yZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fcGFydCAmJiAhdGhpcy5faWdub3JlRGF0YSkge1xuICAgIHRoaXMuX2lnbm9yZURhdGEgPSB0cnVlO1xuICAgIHRoaXMuX3BhcnQub24oJ2Vycm9yJywgRU1QVFlfRk4pO1xuICAgIC8vIHdlIG11c3QgcGVyZm9ybSBzb21lIGtpbmQgb2YgcmVhZCBvbiB0aGUgc3RyZWFtIGV2ZW4gdGhvdWdoIHdlIGFyZVxuICAgIC8vIGlnbm9yaW5nIHRoZSBkYXRhLCBvdGhlcndpc2Ugbm9kZSdzIFJlYWRhYmxlIHN0cmVhbSB3aWxsIG5vdCBlbWl0ICdlbmQnXG4gICAgLy8gYWZ0ZXIgcHVzaGluZyBudWxsIHRvIHRoZSBzdHJlYW1cbiAgICB0aGlzLl9wYXJ0LnJlc3VtZSgpO1xuICB9XG59O1xuXG5EaWNlci5wcm90b3R5cGUuX29uaW5mbyA9IGZ1bmN0aW9uKGlzTWF0Y2gsIGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ1Ziwgc2VsZiA9IHRoaXMsIGkgPSAwLCByLCBldiwgc2hvdWxkV3JpdGVNb3JlID0gdHJ1ZTtcblxuICBpZiAoIXRoaXMuX3BhcnQgJiYgdGhpcy5fanVzdE1hdGNoZWQgJiYgZGF0YSkge1xuICAgIHdoaWxlICh0aGlzLl9kYXNoZXMgPCAyICYmIChzdGFydCArIGkpIDwgZW5kKSB7XG4gICAgICBpZiAoZGF0YVtzdGFydCArIGldID09PSBEQVNIKSB7XG4gICAgICAgICsraTtcbiAgICAgICAgKyt0aGlzLl9kYXNoZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fZGFzaGVzKVxuICAgICAgICAgIGJ1ZiA9IEJfT05FREFTSDtcbiAgICAgICAgdGhpcy5fZGFzaGVzID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9kYXNoZXMgPT09IDIpIHtcbiAgICAgIGlmICgoc3RhcnQgKyBpKSA8IGVuZCAmJiB0aGlzLl9ldmVudHMudHJhaWxlcilcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFpbGVyJywgZGF0YS5zbGljZShzdGFydCArIGksIGVuZCkpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgLy8gbm8gbW9yZSBwYXJ0cyB3aWxsIGJlIGFkZGVkXG4gICAgICBpZiAoc2VsZi5fcGFydHMgPT09IDApIHtcbiAgICAgICAgc2VsZi5fcmVhbEZpbmlzaCA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgIHNlbGYuX3JlYWxGaW5pc2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2Rhc2hlcylcbiAgICAgIHJldHVybjtcbiAgfVxuICBpZiAodGhpcy5fanVzdE1hdGNoZWQpXG4gICAgdGhpcy5fanVzdE1hdGNoZWQgPSBmYWxzZTtcbiAgaWYgKCF0aGlzLl9wYXJ0KSB7XG4gICAgdGhpcy5fcGFydCA9IG5ldyBQYXJ0U3RyZWFtKHRoaXMuX3BhcnRPcHRzKTtcbiAgICB0aGlzLl9wYXJ0Ll9yZWFkID0gZnVuY3Rpb24obikge1xuICAgICAgc2VsZi5fdW5wYXVzZSgpO1xuICAgIH07XG4gICAgZXYgPSB0aGlzLl9pc1ByZWFtYmxlID8gJ3ByZWFtYmxlJyA6ICdwYXJ0JztcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2XSlcbiAgICAgIHRoaXMuZW1pdChldiwgdGhpcy5fcGFydCk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5faWdub3JlKCk7XG4gICAgaWYgKCF0aGlzLl9pc1ByZWFtYmxlKVxuICAgICAgdGhpcy5faW5IZWFkZXIgPSB0cnVlO1xuICB9XG4gIGlmIChkYXRhICYmIHN0YXJ0IDwgZW5kICYmICF0aGlzLl9pZ25vcmVEYXRhKSB7XG4gICAgaWYgKHRoaXMuX2lzUHJlYW1ibGUgfHwgIXRoaXMuX2luSGVhZGVyKSB7XG4gICAgICBpZiAoYnVmKVxuICAgICAgICBzaG91bGRXcml0ZU1vcmUgPSB0aGlzLl9wYXJ0LnB1c2goYnVmKTtcbiAgICAgIHNob3VsZFdyaXRlTW9yZSA9IHRoaXMuX3BhcnQucHVzaChkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgIGlmICghc2hvdWxkV3JpdGVNb3JlKVxuICAgICAgICB0aGlzLl9wYXVzZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNQcmVhbWJsZSAmJiB0aGlzLl9pbkhlYWRlcikge1xuICAgICAgaWYgKGJ1ZilcbiAgICAgICAgdGhpcy5faHBhcnNlci5wdXNoKGJ1Zik7XG4gICAgICByID0gdGhpcy5faHBhcnNlci5wdXNoKGRhdGEuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgaWYgKCF0aGlzLl9pbkhlYWRlciAmJiByICE9PSB1bmRlZmluZWQgJiYgciA8IGVuZClcbiAgICAgICAgdGhpcy5fb25pbmZvKGZhbHNlLCBkYXRhLCBzdGFydCArIHIsIGVuZCk7XG4gICAgfVxuICB9XG4gIGlmIChpc01hdGNoKSB7XG4gICAgdGhpcy5faHBhcnNlci5yZXNldCgpO1xuICAgIGlmICh0aGlzLl9pc1ByZWFtYmxlKVxuICAgICAgdGhpcy5faXNQcmVhbWJsZSA9IGZhbHNlO1xuICAgIGVsc2Uge1xuICAgICAgKyt0aGlzLl9wYXJ0cztcbiAgICAgIHRoaXMuX3BhcnQub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1zZWxmLl9wYXJ0cyA9PT0gMCkge1xuICAgICAgICAgIGlmIChzZWxmLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgc2VsZi5fcmVhbEZpbmlzaCA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgICAgc2VsZi5fcmVhbEZpbmlzaCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLl91bnBhdXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcGFydC5wdXNoKG51bGwpO1xuICAgIHRoaXMuX3BhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5faWdub3JlRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuX2p1c3RNYXRjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9kYXNoZXMgPSAwO1xuICB9XG59O1xuXG5EaWNlci5wcm90b3R5cGUuX3VucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9wYXVzZSlcbiAgICByZXR1cm47XG5cbiAgdGhpcy5fcGF1c2UgPSBmYWxzZTtcbiAgaWYgKHRoaXMuX2NiKSB7XG4gICAgdmFyIGNiID0gdGhpcy5fY2I7XG4gICAgdGhpcy5fY2IgPSB1bmRlZmluZWQ7XG4gICAgY2IoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaWNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dicer/lib/Dicer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/dicer/lib/HeaderParser.js":
/*!************************************************!*\
  !*** ./node_modules/dicer/lib/HeaderParser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter),\n    inherits = (__webpack_require__(/*! util */ \"util\").inherits);\n\nvar StreamSearch = __webpack_require__(/*! streamsearch */ \"(rsc)/./node_modules/dicer/node_modules/streamsearch/lib/sbmh.js\");\n\nvar B_DCRLF = new Buffer('\\r\\n\\r\\n'),\n    RE_CRLF = /\\r\\n/g,\n    RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/,\n    MAX_HEADER_PAIRS = 2000, // from node's http.js\n    MAX_HEADER_SIZE = 80 * 1024; // from node's http_parser\n\nfunction HeaderParser(cfg) {\n  EventEmitter.call(this);\n\n  var self = this;\n  this.nread = 0;\n  this.maxed = false;\n  this.npairs = 0;\n  this.maxHeaderPairs = (cfg && typeof cfg.maxHeaderPairs === 'number'\n                         ? cfg.maxHeaderPairs\n                         : MAX_HEADER_PAIRS);\n  this.buffer = '';\n  this.header = {};\n  this.finished = false;\n  this.ss = new StreamSearch(B_DCRLF);\n  this.ss.on('info', function(isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + (end - start) > MAX_HEADER_SIZE) {\n        end = (MAX_HEADER_SIZE - self.nread);\n        self.nread = MAX_HEADER_SIZE;\n      } else\n        self.nread += (end - start);\n\n      if (self.nread === MAX_HEADER_SIZE)\n        self.maxed = true;\n\n      self.buffer += data.toString('binary', start, end);\n    }\n    if (isMatch)\n      self._finish();\n  });\n}\ninherits(HeaderParser, EventEmitter);\n\nHeaderParser.prototype.push = function(data) {\n  var r = this.ss.push(data);\n  if (this.finished)\n    return r;\n};\n\nHeaderParser.prototype.reset = function() {\n  this.finished = false;\n  this.buffer = '';\n  this.header = {};\n  this.ss.reset();\n};\n\nHeaderParser.prototype._finish = function() {\n  if (this.buffer)\n    this._parseHeader();\n  this.ss.matches = this.ss.maxMatches;\n  var header = this.header;\n  this.header = {};\n  this.buffer = '';\n  this.finished = true;\n  this.nread = this.npairs = 0;\n  this.maxed = false;\n  this.emit('header', header);\n};\n\nHeaderParser.prototype._parseHeader = function() {\n  if (this.npairs === this.maxHeaderPairs)\n    return;\n\n  var lines = this.buffer.split(RE_CRLF), len = lines.length, m, h,\n      modded = false;\n\n  for (var i = 0; i < len; ++i) {\n    if (lines[i].length === 0)\n      continue;\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      this.header[h][this.header[h].length - 1] += lines[i];\n    } else {\n      m = RE_HDR.exec(lines[i]);\n      if (m) {\n        h = m[1].toLowerCase();\n        if (m[2]) {\n          if (this.header[h] === undefined)\n            this.header[h] = [m[2]];\n          else\n            this.header[h].push(m[2]);\n        } else\n          this.header[h] = [''];\n        if (++this.npairs === this.maxHeaderPairs)\n          break;\n      } else {\n        this.buffer = lines[i];\n        modded = true;\n        break;\n      }\n    }\n  }\n  if (!modded)\n    this.buffer = '';\n};\n\nmodule.exports = HeaderParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGljZXIvbGliL0hlYWRlclBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsMERBQThCO0FBQ2pELGVBQWUsa0RBQXdCOztBQUV2QyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBYzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92cmlzdG8tbmV4dC8uL25vZGVfbW9kdWxlcy9kaWNlci9saWIvSGVhZGVyUGFyc2VyLmpzPzI2MjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcixcbiAgICBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcblxudmFyIFN0cmVhbVNlYXJjaCA9IHJlcXVpcmUoJ3N0cmVhbXNlYXJjaCcpO1xuXG52YXIgQl9EQ1JMRiA9IG5ldyBCdWZmZXIoJ1xcclxcblxcclxcbicpLFxuICAgIFJFX0NSTEYgPSAvXFxyXFxuL2csXG4gICAgUkVfSERSID0gL14oW146XSspOlsgXFx0XT8oW1xceDAwLVxceEZGXSspPyQvLFxuICAgIE1BWF9IRUFERVJfUEFJUlMgPSAyMDAwLCAvLyBmcm9tIG5vZGUncyBodHRwLmpzXG4gICAgTUFYX0hFQURFUl9TSVpFID0gODAgKiAxMDI0OyAvLyBmcm9tIG5vZGUncyBodHRwX3BhcnNlclxuXG5mdW5jdGlvbiBIZWFkZXJQYXJzZXIoY2ZnKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5ucmVhZCA9IDA7XG4gIHRoaXMubWF4ZWQgPSBmYWxzZTtcbiAgdGhpcy5ucGFpcnMgPSAwO1xuICB0aGlzLm1heEhlYWRlclBhaXJzID0gKGNmZyAmJiB0eXBlb2YgY2ZnLm1heEhlYWRlclBhaXJzID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgID8gY2ZnLm1heEhlYWRlclBhaXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgOiBNQVhfSEVBREVSX1BBSVJTKTtcbiAgdGhpcy5idWZmZXIgPSAnJztcbiAgdGhpcy5oZWFkZXIgPSB7fTtcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICB0aGlzLnNzID0gbmV3IFN0cmVhbVNlYXJjaChCX0RDUkxGKTtcbiAgdGhpcy5zcy5vbignaW5mbycsIGZ1bmN0aW9uKGlzTWF0Y2gsIGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoZGF0YSAmJiAhc2VsZi5tYXhlZCkge1xuICAgICAgaWYgKHNlbGYubnJlYWQgKyAoZW5kIC0gc3RhcnQpID4gTUFYX0hFQURFUl9TSVpFKSB7XG4gICAgICAgIGVuZCA9IChNQVhfSEVBREVSX1NJWkUgLSBzZWxmLm5yZWFkKTtcbiAgICAgICAgc2VsZi5ucmVhZCA9IE1BWF9IRUFERVJfU0laRTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBzZWxmLm5yZWFkICs9IChlbmQgLSBzdGFydCk7XG5cbiAgICAgIGlmIChzZWxmLm5yZWFkID09PSBNQVhfSEVBREVSX1NJWkUpXG4gICAgICAgIHNlbGYubWF4ZWQgPSB0cnVlO1xuXG4gICAgICBzZWxmLmJ1ZmZlciArPSBkYXRhLnRvU3RyaW5nKCdiaW5hcnknLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgaWYgKGlzTWF0Y2gpXG4gICAgICBzZWxmLl9maW5pc2goKTtcbiAgfSk7XG59XG5pbmhlcml0cyhIZWFkZXJQYXJzZXIsIEV2ZW50RW1pdHRlcik7XG5cbkhlYWRlclBhcnNlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHIgPSB0aGlzLnNzLnB1c2goZGF0YSk7XG4gIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgIHJldHVybiByO1xufTtcblxuSGVhZGVyUGFyc2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gIHRoaXMuYnVmZmVyID0gJyc7XG4gIHRoaXMuaGVhZGVyID0ge307XG4gIHRoaXMuc3MucmVzZXQoKTtcbn07XG5cbkhlYWRlclBhcnNlci5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5idWZmZXIpXG4gICAgdGhpcy5fcGFyc2VIZWFkZXIoKTtcbiAgdGhpcy5zcy5tYXRjaGVzID0gdGhpcy5zcy5tYXhNYXRjaGVzO1xuICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXI7XG4gIHRoaXMuaGVhZGVyID0ge307XG4gIHRoaXMuYnVmZmVyID0gJyc7XG4gIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICB0aGlzLm5yZWFkID0gdGhpcy5ucGFpcnMgPSAwO1xuICB0aGlzLm1heGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnaGVhZGVyJywgaGVhZGVyKTtcbn07XG5cbkhlYWRlclBhcnNlci5wcm90b3R5cGUuX3BhcnNlSGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm5wYWlycyA9PT0gdGhpcy5tYXhIZWFkZXJQYWlycylcbiAgICByZXR1cm47XG5cbiAgdmFyIGxpbmVzID0gdGhpcy5idWZmZXIuc3BsaXQoUkVfQ1JMRiksIGxlbiA9IGxpbmVzLmxlbmd0aCwgbSwgaCxcbiAgICAgIG1vZGRlZCA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAobGluZXNbaV0ubGVuZ3RoID09PSAwKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGxpbmVzW2ldWzBdID09PSAnXFx0JyB8fCBsaW5lc1tpXVswXSA9PT0gJyAnKSB7XG4gICAgICAvLyBmb2xkZWQgaGVhZGVyIGNvbnRlbnRcbiAgICAgIC8vIFJGQzI4MjIgc2F5cyB0byBqdXN0IHJlbW92ZSB0aGUgQ1JMRiBhbmQgbm90IHRoZSB3aGl0ZXNwYWNlIGZvbGxvd2luZ1xuICAgICAgLy8gaXQsIHNvIHdlIGZvbGxvdyB0aGUgUkZDIGFuZCBpbmNsdWRlIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2UgLi4uXG4gICAgICB0aGlzLmhlYWRlcltoXVt0aGlzLmhlYWRlcltoXS5sZW5ndGggLSAxXSArPSBsaW5lc1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IFJFX0hEUi5leGVjKGxpbmVzW2ldKTtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIGggPSBtWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGVhZGVyW2hdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmhlYWRlcltoXSA9IFttWzJdXTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmhlYWRlcltoXS5wdXNoKG1bMl0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aGlzLmhlYWRlcltoXSA9IFsnJ107XG4gICAgICAgIGlmICgrK3RoaXMubnBhaXJzID09PSB0aGlzLm1heEhlYWRlclBhaXJzKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBsaW5lc1tpXTtcbiAgICAgICAgbW9kZGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghbW9kZGVkKVxuICAgIHRoaXMuYnVmZmVyID0gJyc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRlclBhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dicer/lib/HeaderParser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/dicer/lib/PartStream.js":
/*!**********************************************!*\
  !*** ./node_modules/dicer/lib/PartStream.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var inherits = (__webpack_require__(/*! util */ \"util\").inherits),\n    ReadableStream = (__webpack_require__(/*! stream */ \"stream\").Readable) || __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\n\nfunction PartStream(opts) {\n  ReadableStream.call(this, opts);\n}\ninherits(PartStream, ReadableStream);\n\nPartStream.prototype._read = function(n) {};\n\nmodule.exports = PartStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGljZXIvbGliL1BhcnRTdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxrREFBd0I7QUFDdkMscUJBQXFCLHNEQUEwQixJQUFJLG1CQUFPLENBQUMseUVBQWlCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZyaXN0by1uZXh0Ly4vbm9kZV9tb2R1bGVzL2RpY2VyL2xpYi9QYXJ0U3RyZWFtLmpzP2Q4ODkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzLFxuICAgIFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGUgfHwgcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIFBhcnRTdHJlYW0ob3B0cykge1xuICBSZWFkYWJsZVN0cmVhbS5jYWxsKHRoaXMsIG9wdHMpO1xufVxuaW5oZXJpdHMoUGFydFN0cmVhbSwgUmVhZGFibGVTdHJlYW0pO1xuXG5QYXJ0U3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRTdHJlYW07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dicer/lib/PartStream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/dicer/node_modules/streamsearch/lib/sbmh.js":
/*!******************************************************************!*\
  !*** ./node_modules/dicer/node_modules/streamsearch/lib/sbmh.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter),\n    inherits = (__webpack_require__(/*! util */ \"util\").inherits);\n\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2)\n    if (buf1[pos1] !== buf2[pos2])\n      return false;\n  return true;\n}\n\nfunction SBMH(needle) {\n  if (typeof needle === 'string')\n    needle = new Buffer(needle);\n  var i, j, needle_len = needle.length;\n\n  this.maxMatches = Infinity;\n  this.matches = 0;\n\n  this._occ = new Array(256);\n  this._lookbehind_size = 0;\n  this._needle = needle;\n  this._bufpos = 0;\n\n  this._lookbehind = new Buffer(needle_len);\n\n  // Initialize occurrence table.\n  for (j = 0; j < 256; ++j)\n    this._occ[j] = needle_len;\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  if (needle_len >= 1) {\n    for (i = 0; i < needle_len - 1; ++i)\n      this._occ[needle[i]] = needle_len - 1 - i;\n  }\n}\ninherits(SBMH, EventEmitter);\n\nSBMH.prototype.reset = function() {\n  this._lookbehind_size = 0;\n  this.matches = 0;\n  this._bufpos = 0;\n};\n\nSBMH.prototype.push = function(chunk, pos) {\n  var r, chlen;\n  if (!Buffer.isBuffer(chunk))\n    chunk = new Buffer(chunk, 'binary');\n  chlen = chunk.length;\n  this._bufpos = pos || 0;\n  while (r !== chlen && this.matches < this.maxMatches)\n    r = this._sbmh_feed(chunk);\n  return r;\n};\n\nSBMH.prototype._sbmh_feed = function(data) {\n  var len = data.length, needle = this._needle, needle_len = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  var pos = -this._lookbehind_size,\n      last_needle_char = needle[needle_len - 1],\n      occ = this._occ,\n      lookbehind = this._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needle_len) {\n       var ch = this._sbmh_lookup_char(data, pos + needle_len - 1);\n\n      if (ch === last_needle_char\n          && this._sbmh_memcmp(data, pos, needle_len - 1)) {\n        this._lookbehind_size = 0;\n        ++this.matches;\n        if (pos > -this._lookbehind_size)\n          this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos);\n        else\n          this.emit('info', true);\n\n        this._bufpos = pos + needle_len;\n        return pos + needle_len;\n      } else\n        pos += occ[ch];\n    }\n\n    // No match.\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))\n        pos++;\n    }\n\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, lookbehind, 0, this._lookbehind_size);\n      this._lookbehind_size = 0;\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      var bytesToCutOff = this._lookbehind_size + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, lookbehind, 0, bytesToCutOff);\n      }\n\n      lookbehind.copy(lookbehind, 0, bytesToCutOff,\n                      this._lookbehind_size - bytesToCutOff);\n      this._lookbehind_size -= bytesToCutOff;\n\n      data.copy(lookbehind, this._lookbehind_size);\n      this._lookbehind_size += len;\n\n      this._bufpos = len;\n      return len;\n    }\n  }\n\n  if (pos >= 0)\n    pos += this._bufpos;\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= len - needle_len) {\n    var ch = data[pos + needle_len - 1];\n\n    if (ch === last_needle_char\n        && data[pos] === needle[0]\n        && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\n      ++this.matches;\n      if (pos > 0)\n        this.emit('info', true, data, this._bufpos, pos);\n      else\n        this.emit('info', true);\n\n      this._bufpos = pos + needle_len;\n      return pos + needle_len;\n    } else\n      pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  if (pos < len) {\n    while (pos < len && (data[pos] !== needle[0]\n                         || !jsmemcmp(data, pos, needle, 0, len - pos))) {\n      ++pos;\n    }\n    if (pos < len) {\n      data.copy(lookbehind, 0, pos, pos + (len - pos));\n      this._lookbehind_size = len - pos;\n    }\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos > 0)\n    this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n\n  this._bufpos = len;\n  return len;\n};\n\nSBMH.prototype._sbmh_lookup_char = function(data, pos) {\n  if (pos < 0)\n    return this._lookbehind[this._lookbehind_size + pos];\n  else\n    return data[pos];\n}\n\nSBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n  var i = 0;\n\n  while (i < len) {\n    if (this._sbmh_lookup_char(data, pos + i) === this._needle[i])\n      ++i;\n    else\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = SBMH;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZGljZXIvbm9kZV9tb2R1bGVzL3N0cmVhbXNlYXJjaC9saWIvc2JtaC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBOEI7QUFDakQsZUFBZSxrREFBd0I7O0FBRXZDO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZyaXN0by1uZXh0Ly4vbm9kZV9tb2R1bGVzL2RpY2VyL25vZGVfbW9kdWxlcy9zdHJlYW1zZWFyY2gvbGliL3NibWguanM/ZTQ0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBCYXNlZCBoZWF2aWx5IG9uIHRoZSBTdHJlYW1pbmcgQm95ZXItTW9vcmUtSG9yc3Bvb2wgQysrIGltcGxlbWVudGF0aW9uXG4gIGJ5IEhvbmdsaSBMYWkgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9Gb29CYXJXaWRnZXQvYm95ZXItbW9vcmUtaG9yc3Bvb2xcbiovXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxuICAgIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xuXG5mdW5jdGlvbiBqc21lbWNtcChidWYxLCBwb3MxLCBidWYyLCBwb3MyLCBudW0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07ICsraSwgKytwb3MxLCArK3BvczIpXG4gICAgaWYgKGJ1ZjFbcG9zMV0gIT09IGJ1ZjJbcG9zMl0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBTQk1IKG5lZWRsZSkge1xuICBpZiAodHlwZW9mIG5lZWRsZSA9PT0gJ3N0cmluZycpXG4gICAgbmVlZGxlID0gbmV3IEJ1ZmZlcihuZWVkbGUpO1xuICB2YXIgaSwgaiwgbmVlZGxlX2xlbiA9IG5lZWRsZS5sZW5ndGg7XG5cbiAgdGhpcy5tYXhNYXRjaGVzID0gSW5maW5pdHk7XG4gIHRoaXMubWF0Y2hlcyA9IDA7XG5cbiAgdGhpcy5fb2NjID0gbmV3IEFycmF5KDI1Nik7XG4gIHRoaXMuX2xvb2tiZWhpbmRfc2l6ZSA9IDA7XG4gIHRoaXMuX25lZWRsZSA9IG5lZWRsZTtcbiAgdGhpcy5fYnVmcG9zID0gMDtcblxuICB0aGlzLl9sb29rYmVoaW5kID0gbmV3IEJ1ZmZlcihuZWVkbGVfbGVuKTtcblxuICAvLyBJbml0aWFsaXplIG9jY3VycmVuY2UgdGFibGUuXG4gIGZvciAoaiA9IDA7IGogPCAyNTY7ICsrailcbiAgICB0aGlzLl9vY2Nbal0gPSBuZWVkbGVfbGVuO1xuXG4gIC8vIFBvcHVsYXRlIG9jY3VycmVuY2UgdGFibGUgd2l0aCBhbmFseXNpcyBvZiB0aGUgbmVlZGxlLFxuICAvLyBpZ25vcmluZyBsYXN0IGxldHRlci5cbiAgaWYgKG5lZWRsZV9sZW4gPj0gMSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuZWVkbGVfbGVuIC0gMTsgKytpKVxuICAgICAgdGhpcy5fb2NjW25lZWRsZVtpXV0gPSBuZWVkbGVfbGVuIC0gMSAtIGk7XG4gIH1cbn1cbmluaGVyaXRzKFNCTUgsIEV2ZW50RW1pdHRlcik7XG5cblNCTUgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2xvb2tiZWhpbmRfc2l6ZSA9IDA7XG4gIHRoaXMubWF0Y2hlcyA9IDA7XG4gIHRoaXMuX2J1ZnBvcyA9IDA7XG59O1xuXG5TQk1ILnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIHBvcykge1xuICB2YXIgciwgY2hsZW47XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssICdiaW5hcnknKTtcbiAgY2hsZW4gPSBjaHVuay5sZW5ndGg7XG4gIHRoaXMuX2J1ZnBvcyA9IHBvcyB8fCAwO1xuICB3aGlsZSAociAhPT0gY2hsZW4gJiYgdGhpcy5tYXRjaGVzIDwgdGhpcy5tYXhNYXRjaGVzKVxuICAgIHIgPSB0aGlzLl9zYm1oX2ZlZWQoY2h1bmspO1xuICByZXR1cm4gcjtcbn07XG5cblNCTUgucHJvdG90eXBlLl9zYm1oX2ZlZWQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBsZW4gPSBkYXRhLmxlbmd0aCwgbmVlZGxlID0gdGhpcy5fbmVlZGxlLCBuZWVkbGVfbGVuID0gbmVlZGxlLmxlbmd0aDtcblxuICAvLyBQb3NpdGl2ZTogcG9pbnRzIHRvIGEgcG9zaXRpb24gaW4gYGRhdGFgXG4gIC8vICAgICAgICAgICBwb3MgPT0gMyBwb2ludHMgdG8gZGF0YVszXVxuICAvLyBOZWdhdGl2ZTogcG9pbnRzIHRvIGEgcG9zaXRpb24gaW4gdGhlIGxvb2tiZWhpbmQgYnVmZmVyXG4gIC8vICAgICAgICAgICBwb3MgPT0gLTIgcG9pbnRzIHRvIGxvb2tiZWhpbmRbbG9va2JlaGluZF9zaXplIC0gMl1cbiAgdmFyIHBvcyA9IC10aGlzLl9sb29rYmVoaW5kX3NpemUsXG4gICAgICBsYXN0X25lZWRsZV9jaGFyID0gbmVlZGxlW25lZWRsZV9sZW4gLSAxXSxcbiAgICAgIG9jYyA9IHRoaXMuX29jYyxcbiAgICAgIGxvb2tiZWhpbmQgPSB0aGlzLl9sb29rYmVoaW5kO1xuXG4gIGlmIChwb3MgPCAwKSB7XG4gICAgLy8gTG9va2JlaGluZCBidWZmZXIgaXMgbm90IGVtcHR5LiBQZXJmb3JtIEJveWVyLU1vb3JlLUhvcnNwb29sXG4gICAgLy8gc2VhcmNoIHdpdGggY2hhcmFjdGVyIGxvb2t1cCBjb2RlIHRoYXQgY29uc2lkZXJzIGJvdGggdGhlXG4gICAgLy8gbG9va2JlaGluZCBidWZmZXIgYW5kIHRoZSBjdXJyZW50IHJvdW5kJ3MgaGF5c3RhY2sgZGF0YS5cbiAgICAvL1xuICAgIC8vIExvb3AgdW50aWxcbiAgICAvLyAgIHRoZXJlIGlzIGEgbWF0Y2guXG4gICAgLy8gb3IgdW50aWxcbiAgICAvLyAgIHdlJ3ZlIG1vdmVkIHBhc3QgdGhlIHBvc2l0aW9uIHRoYXQgcmVxdWlyZXMgdGhlXG4gICAgLy8gICBsb29rYmVoaW5kIGJ1ZmZlci4gSW4gdGhpcyBjYXNlIHdlIHN3aXRjaCB0byB0aGVcbiAgICAvLyAgIG9wdGltaXplZCBsb29wLlxuICAgIC8vIG9yIHVudGlsXG4gICAgLy8gICB0aGUgY2hhcmFjdGVyIHRvIGxvb2sgYXQgbGllcyBvdXRzaWRlIHRoZSBoYXlzdGFjay5cbiAgICB3aGlsZSAocG9zIDwgMCAmJiBwb3MgPD0gbGVuIC0gbmVlZGxlX2xlbikge1xuICAgICAgIHZhciBjaCA9IHRoaXMuX3NibWhfbG9va3VwX2NoYXIoZGF0YSwgcG9zICsgbmVlZGxlX2xlbiAtIDEpO1xuXG4gICAgICBpZiAoY2ggPT09IGxhc3RfbmVlZGxlX2NoYXJcbiAgICAgICAgICAmJiB0aGlzLl9zYm1oX21lbWNtcChkYXRhLCBwb3MsIG5lZWRsZV9sZW4gLSAxKSkge1xuICAgICAgICB0aGlzLl9sb29rYmVoaW5kX3NpemUgPSAwO1xuICAgICAgICArK3RoaXMubWF0Y2hlcztcbiAgICAgICAgaWYgKHBvcyA+IC10aGlzLl9sb29rYmVoaW5kX3NpemUpXG4gICAgICAgICAgdGhpcy5lbWl0KCdpbmZvJywgdHJ1ZSwgbG9va2JlaGluZCwgMCwgdGhpcy5fbG9va2JlaGluZF9zaXplICsgcG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuZW1pdCgnaW5mbycsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2J1ZnBvcyA9IHBvcyArIG5lZWRsZV9sZW47XG4gICAgICAgIHJldHVybiBwb3MgKyBuZWVkbGVfbGVuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHBvcyArPSBvY2NbY2hdO1xuICAgIH1cblxuICAgIC8vIE5vIG1hdGNoLlxuXG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIC8vIFRoZXJlJ3MgdG9vIGZldyBkYXRhIGZvciBCb3llci1Nb29yZS1Ib3JzcG9vbCB0byBydW4sXG4gICAgICAvLyBzbyBsZXQncyB1c2UgYSBkaWZmZXJlbnQgYWxnb3JpdGhtIHRvIHNraXAgYXMgbXVjaCBhc1xuICAgICAgLy8gd2UgY2FuLlxuICAgICAgLy8gRm9yd2FyZCBwb3MgdW50aWxcbiAgICAgIC8vICAgdGhlIHRyYWlsaW5nIHBhcnQgb2YgbG9va2JlaGluZCArIGRhdGFcbiAgICAgIC8vICAgbG9va3MgbGlrZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZWVkbGVcbiAgICAgIC8vIG9yIHVudGlsXG4gICAgICAvLyAgIHBvcyA9PSAwXG4gICAgICB3aGlsZSAocG9zIDwgMCAmJiAhdGhpcy5fc2JtaF9tZW1jbXAoZGF0YSwgcG9zLCBsZW4gLSBwb3MpKVxuICAgICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIERpc2NhcmQgbG9va2JlaGluZCBidWZmZXIuXG4gICAgICB0aGlzLmVtaXQoJ2luZm8nLCBmYWxzZSwgbG9va2JlaGluZCwgMCwgdGhpcy5fbG9va2JlaGluZF9zaXplKTtcbiAgICAgIHRoaXMuX2xvb2tiZWhpbmRfc2l6ZSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN1dCBvZmYgcGFydCBvZiB0aGUgbG9va2JlaGluZCBidWZmZXIgdGhhdCBoYXNcbiAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkIGFuZCBhcHBlbmQgdGhlIGVudGlyZSBoYXlzdGFja1xuICAgICAgLy8gaW50byBpdC5cbiAgICAgIHZhciBieXRlc1RvQ3V0T2ZmID0gdGhpcy5fbG9va2JlaGluZF9zaXplICsgcG9zO1xuXG4gICAgICBpZiAoYnl0ZXNUb0N1dE9mZiA+IDApIHtcbiAgICAgICAgLy8gVGhlIGN1dCBvZmYgZGF0YSBpcyBndWFyYW50ZWVkIG5vdCB0byBjb250YWluIHRoZSBuZWVkbGUuXG4gICAgICAgIHRoaXMuZW1pdCgnaW5mbycsIGZhbHNlLCBsb29rYmVoaW5kLCAwLCBieXRlc1RvQ3V0T2ZmKTtcbiAgICAgIH1cblxuICAgICAgbG9va2JlaGluZC5jb3B5KGxvb2tiZWhpbmQsIDAsIGJ5dGVzVG9DdXRPZmYsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9va2JlaGluZF9zaXplIC0gYnl0ZXNUb0N1dE9mZik7XG4gICAgICB0aGlzLl9sb29rYmVoaW5kX3NpemUgLT0gYnl0ZXNUb0N1dE9mZjtcblxuICAgICAgZGF0YS5jb3B5KGxvb2tiZWhpbmQsIHRoaXMuX2xvb2tiZWhpbmRfc2l6ZSk7XG4gICAgICB0aGlzLl9sb29rYmVoaW5kX3NpemUgKz0gbGVuO1xuXG4gICAgICB0aGlzLl9idWZwb3MgPSBsZW47XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwb3MgPj0gMClcbiAgICBwb3MgKz0gdGhpcy5fYnVmcG9zO1xuXG4gIC8vIExvb2tiZWhpbmQgYnVmZmVyIGlzIG5vdyBlbXB0eS4gUGVyZm9ybSBCb3llci1Nb29yZS1Ib3JzcG9vbFxuICAvLyBzZWFyY2ggd2l0aCBvcHRpbWl6ZWQgY2hhcmFjdGVyIGxvb2t1cCBjb2RlIHRoYXQgb25seSBjb25zaWRlcnNcbiAgLy8gdGhlIGN1cnJlbnQgcm91bmQncyBoYXlzdGFjayBkYXRhLlxuICB3aGlsZSAocG9zIDw9IGxlbiAtIG5lZWRsZV9sZW4pIHtcbiAgICB2YXIgY2ggPSBkYXRhW3BvcyArIG5lZWRsZV9sZW4gLSAxXTtcblxuICAgIGlmIChjaCA9PT0gbGFzdF9uZWVkbGVfY2hhclxuICAgICAgICAmJiBkYXRhW3Bvc10gPT09IG5lZWRsZVswXVxuICAgICAgICAmJiBqc21lbWNtcChuZWVkbGUsIDAsIGRhdGEsIHBvcywgbmVlZGxlX2xlbiAtIDEpKSB7XG4gICAgICArK3RoaXMubWF0Y2hlcztcbiAgICAgIGlmIChwb3MgPiAwKVxuICAgICAgICB0aGlzLmVtaXQoJ2luZm8nLCB0cnVlLCBkYXRhLCB0aGlzLl9idWZwb3MsIHBvcyk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuZW1pdCgnaW5mbycsIHRydWUpO1xuXG4gICAgICB0aGlzLl9idWZwb3MgPSBwb3MgKyBuZWVkbGVfbGVuO1xuICAgICAgcmV0dXJuIHBvcyArIG5lZWRsZV9sZW47XG4gICAgfSBlbHNlXG4gICAgICBwb3MgKz0gb2NjW2NoXTtcbiAgfVxuXG4gIC8vIFRoZXJlIHdhcyBubyBtYXRjaC4gSWYgdGhlcmUncyB0cmFpbGluZyBoYXlzdGFjayBkYXRhIHRoYXQgd2UgY2Fubm90XG4gIC8vIG1hdGNoIHlldCB1c2luZyB0aGUgQm95ZXItTW9vcmUtSG9yc3Bvb2wgYWxnb3JpdGhtIChiZWNhdXNlIHRoZSB0cmFpbGluZ1xuICAvLyBkYXRhIGlzIGxlc3MgdGhhbiB0aGUgbmVlZGxlIHNpemUpIHRoZW4gbWF0Y2ggdXNpbmcgYSBtb2RpZmllZFxuICAvLyBhbGdvcml0aG0gdGhhdCBzdGFydHMgbWF0Y2hpbmcgZnJvbSB0aGUgYmVnaW5uaW5nIGluc3RlYWQgb2YgdGhlIGVuZC5cbiAgLy8gV2hhdGV2ZXIgdHJhaWxpbmcgZGF0YSBpcyBsZWZ0IGFmdGVyIHJ1bm5pbmcgdGhpcyBhbGdvcml0aG0gaXMgYWRkZWQgdG9cbiAgLy8gdGhlIGxvb2tiZWhpbmQgYnVmZmVyLlxuICBpZiAocG9zIDwgbGVuKSB7XG4gICAgd2hpbGUgKHBvcyA8IGxlbiAmJiAoZGF0YVtwb3NdICE9PSBuZWVkbGVbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICB8fCAhanNtZW1jbXAoZGF0YSwgcG9zLCBuZWVkbGUsIDAsIGxlbiAtIHBvcykpKSB7XG4gICAgICArK3BvcztcbiAgICB9XG4gICAgaWYgKHBvcyA8IGxlbikge1xuICAgICAgZGF0YS5jb3B5KGxvb2tiZWhpbmQsIDAsIHBvcywgcG9zICsgKGxlbiAtIHBvcykpO1xuICAgICAgdGhpcy5fbG9va2JlaGluZF9zaXplID0gbGVuIC0gcG9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIEV2ZXJ5dGhpbmcgdW50aWwgcG9zIGlzIGd1YXJhbnRlZWQgbm90IHRvIGNvbnRhaW4gbmVlZGxlIGRhdGEuXG4gIGlmIChwb3MgPiAwKVxuICAgIHRoaXMuZW1pdCgnaW5mbycsIGZhbHNlLCBkYXRhLCB0aGlzLl9idWZwb3MsIHBvcyA8IGxlbiA/IHBvcyA6IGxlbik7XG5cbiAgdGhpcy5fYnVmcG9zID0gbGVuO1xuICByZXR1cm4gbGVuO1xufTtcblxuU0JNSC5wcm90b3R5cGUuX3NibWhfbG9va3VwX2NoYXIgPSBmdW5jdGlvbihkYXRhLCBwb3MpIHtcbiAgaWYgKHBvcyA8IDApXG4gICAgcmV0dXJuIHRoaXMuX2xvb2tiZWhpbmRbdGhpcy5fbG9va2JlaGluZF9zaXplICsgcG9zXTtcbiAgZWxzZVxuICAgIHJldHVybiBkYXRhW3Bvc107XG59XG5cblNCTUgucHJvdG90eXBlLl9zYm1oX21lbWNtcCA9IGZ1bmN0aW9uKGRhdGEsIHBvcywgbGVuKSB7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICh0aGlzLl9zYm1oX2xvb2t1cF9jaGFyKGRhdGEsIHBvcyArIGkpID09PSB0aGlzLl9uZWVkbGVbaV0pXG4gICAgICArK2k7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNCTUg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dicer/node_modules/streamsearch/lib/sbmh.js\n");

/***/ })

};
;